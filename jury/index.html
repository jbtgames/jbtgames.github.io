<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jury Game 3.0 • Live Courtroom</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/inter@5.0.16/variable.css">
  <style>
    :root {
      color-scheme: only light;
      --bg: linear-gradient(135deg, #fef6ec 0%, #f0f7ff 45%, #f9f2ff 100%);
      --text: #0f1b3d;
      --muted: #445274;
      --muted-strong: #152046;
      --accent: #6366f1;
      --accent-strong: #4338ca;
      --accent-soft: rgba(99, 102, 241, 0.14);
      --accent-secondary: #f97316;
      --accent-secondary-soft: rgba(249, 115, 22, 0.16);
      --border: rgba(15, 27, 61, 0.08);
      --card-bg: rgba(255, 255, 255, 0.82);
      --surface: rgba(255, 255, 255, 0.68);
      --shadow: 0 28px 54px rgba(15, 27, 61, 0.16);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "InterVariable", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 64px 16px 120px;
    }

    main {
      width: min(960px, 100%);
      display: grid;
      gap: 32px;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 28px;
      padding: 36px;
      backdrop-filter: blur(16px);
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px solid var(--border);
      pointer-events: none;
    }

    h1, h2, h3 {
      margin: 0 0 16px;
      line-height: 1.1;
    }

    p {
      margin: 0 0 16px;
      line-height: 1.6;
      color: var(--muted);
      font-size: 1.02rem;
    }

    .hero {
      display: grid;
      gap: 36px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: stretch;
    }

    .hero-body {
      display: grid;
      gap: 20px;
    }

    .hero-body p {
      font-size: 1.08rem;
      color: var(--muted);
    }

    .hero-foot {
      display: grid;
      gap: 20px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.7);
      color: var(--accent-strong);
      font-weight: 600;
      border-radius: 999px;
      padding: 7px 16px;
      text-transform: uppercase;
      font-size: 0.72rem;
      letter-spacing: 0.12em;
    }

    .hero h1 {
      font-size: clamp(2.5rem, 4.4vw, 3.5rem);
      color: var(--muted-strong);
    }

    .hero-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .metric {
      padding: 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92) 0%, rgba(255, 255, 255, 0.72) 100%);
      display: grid;
      gap: 6px;
      position: relative;
      overflow: hidden;
    }

    .metric::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(95, 77, 255, 0.08) 0%, rgba(255, 255, 255, 0) 60%);
      pointer-events: none;
    }

    .metric span:first-child {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
    }

    .metric span:last-child {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .pill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    .pill {
      padding: 9px 16px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.14);
      color: var(--accent-strong);
      font-weight: 600;
      font-size: 0.82rem;
    }

    .feature-list {
      display: grid;
      gap: 16px;
      margin-top: 8px;
      padding: 0;
      list-style: none;
    }

    .feature {
      display: grid;
      gap: 8px;
      padding: 20px 22px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.54);
      background: rgba(255, 255, 255, 0.74);
    }

    .feature strong {
      font-size: 1.05rem;
      color: var(--text);
    }

    .timeline {
      display: grid;
      gap: 18px;
      list-style: none;
      padding: 0;
      margin: 20px 0 0;
    }

    .timeline li {
      display: grid;
      gap: 6px;
      padding-left: 22px;
      position: relative;
    }

    .timeline li::before {
      content: "";
      position: absolute;
      left: 0;
      top: 4px;
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(95, 77, 255, 0.14);
    }

    .demo-grid {
      display: grid;
      gap: 24px;
    }

    .demo-actions {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: start;
    }

    .trial-gate {
      display: grid;
      gap: 8px;
      padding: 18px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.86);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.48);
    }

    .trial-tab {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 20px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(99, 102, 241, 0.08);
      color: var(--accent-strong);
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    .trial-tab:disabled {
      cursor: not-allowed;
      opacity: 0.72;
      box-shadow: none;
    }

    .trial-tab--ready {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      color: #fff;
      box-shadow: 0 18px 36px rgba(99, 102, 241, 0.28);
    }

    .trial-tab--ready:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 22px 42px rgba(99, 102, 241, 0.32);
    }

    .trial-tab--running {
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    .trial-tab--deliberated {
      background: var(--accent-secondary-soft);
      color: var(--accent-secondary);
    }

    .trial-tab--done {
      background: rgba(15, 27, 61, 0.08);
      color: var(--muted-strong);
    }

    .trial-hint {
      font-size: 0.82rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .demo-status {
      margin-top: 12px;
      padding: 14px 18px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.54);
      background: rgba(255, 255, 255, 0.72);
      font-size: 0.9rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .demo-panels {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .demo-panel {
      padding: 22px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.52);
      background: rgba(255, 255, 255, 0.74);
      display: grid;
      gap: 14px;
    }

    .input-field {
      display: grid;
      gap: 6px;
    }

    .input-field label {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--muted);
    }

    .input-field input,
    .input-field select {
      border-radius: 999px;
      border: 1px solid rgba(95, 77, 255, 0.24);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 16px;
      font-size: 0.92rem;
      font-family: inherit;
      color: var(--muted-strong);
      outline: none;
    }

    .input-field input:focus,
    .input-field select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(95, 77, 255, 0.16);
    }

    .ai-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .ai-status {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .ai-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
      color: var(--muted);
      font-size: 0.88rem;
    }

    .ai-muted {
      color: rgba(31, 36, 48, 0.6);
      font-size: 0.86rem;
    }

    .demo-panel h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .jury-highlight {
      display: grid;
      gap: 10px;
    }

    .jury-panelists {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .demo-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.82rem;
      color: var(--muted);
    }

    .demo-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .demo-tag {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.16);
      color: var(--accent-strong);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .demo-transcript {
      display: grid;
      gap: 10px;
    }

    .demo-line {
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(95, 77, 255, 0.16);
      background: rgba(95, 77, 255, 0.07);
      font-size: 0.9rem;
      color: var(--muted);
    }

    .demo-line strong {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      margin-bottom: 4px;
    }

    .verdict-callout {
      padding: 16px 18px;
      border-radius: 18px;
      background: rgba(95, 77, 255, 0.14);
      border: 1px solid rgba(95, 77, 255, 0.32);
      color: var(--text);
      display: grid;
      gap: 6px;
    }

    .action-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-top: 24px;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 14px 26px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.98rem;
      letter-spacing: 0.01em;
      text-decoration: none;
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .is-hidden {
      display: none !important;
    }

    .button--primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      color: #fff;
      box-shadow: 0 20px 38px rgba(99, 102, 241, 0.26);
    }

    .button--ghost {
      background: rgba(255, 255, 255, 0.78);
      color: var(--accent);
      border: 1px solid rgba(99, 102, 241, 0.34);
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 24px 42px rgba(99, 102, 241, 0.28);
    }

    .section-intro {
      display: grid;
      gap: 10px;
      margin-bottom: 18px;
    }

    .section-intro span {
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--accent);
      font-weight: 600;
    }

    .docket-list {
      display: grid;
      gap: 16px;
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .docket-item {
      display: grid;
      gap: 12px;
      padding: 20px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.68);
    }

    .docket-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
    }

    .docket-title-group {
      display: grid;
      gap: 6px;
    }

    .docket-title {
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--muted-strong);
      margin: 0;
    }

    .docket-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .metric-chip {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.12);
      color: var(--accent-strong);
      font-size: 0.78rem;
      font-weight: 600;
    }

    .case-metric-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .case-metric {
      display: grid;
      gap: 4px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.52);
      background: rgba(255, 255, 255, 0.7);
    }

    .case-metric span:first-child {
      font-weight: 700;
      font-size: 1.2rem;
      color: var(--accent);
    }

    .case-metric span:last-child {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .signal-pill {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(18, 21, 43, 0.06);
      color: var(--muted-strong);
      font-size: 0.78rem;
      font-weight: 600;
    }

    footer {
      margin-top: 36px;
      text-align: center;
      color: rgba(31, 36, 48, 0.48);
      font-size: 0.85rem;
    }

    @media (max-width: 720px) {
      body {
        padding-top: 40px;
      }

      .card {
        padding: 28px;
      }

      .demo-panels {
        grid-template-columns: 1fr;
      }

      .hero-grid {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="card hero">
      <div class="hero-body">
        <span class="badge">Jury Game 3.0 live build</span>
        <h1>One glass dashboard for trials, verdicts, and archives.</h1>
        <p>
          This is the canonical Jury Game home — the sandbox, verdict log, and telemetry readouts that power the live
          courtroom now sit on a single page. Load new controversies, watch the jury deliberate, and confirm every ruling
          lands in the archive without jumping between prototype links.
        </p>
        <div class="pill-list">
          <span class="pill">Live docket sync</span>
          <span class="pill">Transparent verdict archive</span>
          <span class="pill">Autonomous counsel</span>
          <span class="pill">Optional Groq co-judge</span>
        </div>
        <div class="action-strip">
          <a class="button button--primary" href="#live-trial">Launch the live trial flow</a>
          <a class="button button--ghost" href="#archive">Review resolved cases</a>
        </div>
      </div>
      <div class="hero-foot">
        <div class="hero-grid">
          <div class="metric">
            <span id="metric-active-cases">—</span>
            <span>Active controversies ready to schedule</span>
          </div>
          <div class="metric">
            <span id="metric-queue-depth">—</span>
            <span>Cases waiting in the hourly spotlight queue</span>
          </div>
          <div class="metric">
            <span id="metric-archive-count">—</span>
            <span>Resolved trials logged in the archive</span>
          </div>
          <div class="metric">
            <span id="metric-juror-count">—</span>
            <span>AI jurors on rotation</span>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Live systems</span>
        <h2>What powers the live courtroom</h2>
      </div>
      <p>
        The infrastructure below now backs the public-facing build. Every module pipes into a shared state store so jurors
        and moderators always reference the same facts, telemetry, and transcripts while the case is in flight.
      </p>
      <ul class="feature-list">
        <li class="feature">
          <strong>Persistent case archive</strong>
          <p>
            Cloud-backed storage keeps the docket intact between visits. Cases decay using a freshness score so new posts
            surface organically, while historically significant trials remain searchable.
          </p>
        </li>
        <li class="feature">
          <strong>Cross-visitor synchronization</strong>
          <p>
            The board updates in real-time when jurors vote or comment. We expose a channel log for moderators and a
            visual heartbeat indicator for visitors to confirm when the sim is live.
          </p>
        </li>
        <li class="feature">
          <strong>Autonomous counsel behaviors</strong>
          <p>
            Prosecutor, defender, and mediator agents now reference shared memory. They can resume suspended cases,
            escalate unusual activity, and request human arbitration with a single tap.
          </p>
        </li>
        <li class="feature">
          <strong>Emotion telemetry dashboard</strong>
          <p>
            Sentiment analysis runs on every new comment. Jurors see simplified mood meters while moderators can drill into
            raw scores to understand volatility within each case thread.
          </p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Daily cadence</span>
        <h2>How the trial cycles</h2>
      </div>
      <p>
        The live build processes headline controversies on a predictable loop so you can drop in at any moment. Each phase
        keeps the docket fresh while leaving space to audit transcripts and run manual reviews.
      </p>
      <ul class="timeline">
        <li>
          <strong>Morning — Inbox refresh</strong>
          <p>New filings join the inbox and top-ranking cases queue up for the next public session.</p>
        </li>
        <li>
          <strong>Afternoon — Jury session</strong>
          <p>Panels deliberate with scripted counsel while moderators monitor mood telemetry and vote splits.</p>
        </li>
        <li>
          <strong>Evening — Archive sweep</strong>
          <p>Judge rulings land in the archive, highlight reels generate, and the queue resets for the next cycle.</p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Up Next</span>
        <h2>What we still owe you</h2>
      </div>
      <p>
        Three additional modules are in active development. Expect preview builds through the shared folder before the
        next sync.
      </p>
      <ul class="feature-list">
        <li class="feature">
          <strong>Juror reputation loop</strong>
          <p>Designing streak-based rewards that influence future seating priority without punishing casual players.</p>
        </li>
        <li class="feature">
          <strong>Live verdict broadcast</strong>
          <p>Building a marquee for big decisions, including automated highlight reels for social sharing.</p>
        </li>
        <li class="feature">
          <strong>Scenario writer toolkit</strong>
          <p>Packaging our internal case generator so partners can author bespoke dilemmas with guardrails.</p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Docket</span>
        <h2>Spotlight controversies on the docket</h2>
      </div>
      <p>
        The docket caps at 50 active controversies pulled from today’s news cycle. This same feed powers the sandbox
        below, so anything you see listed here can be queued, deliberated, and archived in real time without swapping
        tabs.
      </p>
      <div id="docket-preview">
        <p class="demo-status">Loading docket metrics…</p>
      </div>
    </section>

    <section class="card" id="live-trial">
      <div class="section-intro">
        <span>Live trial</span>
        <h2>Run the full flow</h2>
      </div>
      <p>
        Queue up the latest community submission, submit it to the jury for deliberation, and then invite the judge to
        finalize the ruling using the deterministic helpers in <code>app.js</code>. Everything loads locally from the JSON
        data pack that also drives the live build, so you’re exercising the exact workflow jurors experience.
      </p>
      <div class="demo-grid">
        <div class="demo-actions">
          <button class="button button--primary" id="demo-queue">Load next headline case</button>
          <div class="trial-gate">
            <button class="trial-tab" id="demo-submit" disabled>Pre-trial</button>
            <span class="trial-hint" id="trial-hint">Queue a case to unlock the courtroom.</span>
          </div>
          <button class="button button--ghost is-hidden" id="demo-judge" disabled>Finalize judge ruling</button>
        </div>
        <div class="demo-status" id="demo-status">Pre-trial — load a case to ready the courtroom.</div>
        <div class="demo-panel ai-panel">
          <h3>Groq deliberation boost</h3>
          <p>Bring your Groq API key to sample an additional AI verdict that weighs both sides of the dispute.</p>
          <div class="input-field">
            <label for="groq-key">Groq API key</label>
            <input type="password" id="groq-key" placeholder="gsk_…" autocomplete="off" spellcheck="false">
          </div>
          <div class="input-field">
            <label for="groq-model">Model</label>
            <select id="groq-model">
              <option value="llama3-70b-8192">llama3-70b-8192</option>
              <option value="llama3-8b-8192">llama3-8b-8192</option>
            </select>
          </div>
          <div class="ai-inline">
            <button class="button button--ghost" id="groq-run" disabled>Request Groq verdict</button>
            <span class="ai-status" id="groq-status">Enter an API key and queue a case to unlock Groq reasoning.</span>
          </div>
        </div>
        <div class="demo-panels">
          <div class="demo-panel" id="demo-case">
            <h3>Active case</h3>
            <p>No case selected yet. Queue a spotlight dispute to inspect metrics before running the trial.</p>
          </div>
          <div class="demo-panel" id="demo-jury">
            <h3>Jury deliberation</h3>
            <p>Submit a queued case to the jury to see how the panel weighs the evidence before the judge rules.</p>
          </div>
          <div class="demo-panel" id="demo-verdict">
            <h3>Judge ruling</h3>
            <p>The final verdict appears here after the judge reviews the jury outcome.</p>
          </div>
          <div class="demo-panel" id="groq-output">
            <h3>Groq AI verdict</h3>
            <p>Connect to Groq and request a verdict to compare external reasoning against the scripted simulation.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="card" id="archive">
      <div class="section-intro">
        <span>Archive</span>
        <h2>Resolved cases</h2>
      </div>
      <p>
        Every ruling recorded in the live sandbox lands here immediately. Audit full briefs, transcripts, and vote splits
        without leaving the page.
      </p>
      <div id="archive-preview">
        <p class="demo-status">Archive populates after rulings are recorded.</p>
      </div>
    </section>
  </main>

  <footer>
    Jury Game 3.0 • Live courtroom build for moderators, jurors, and reviewers
  </footer>

  <script src="app.js"></script>
  <script>
    (function () {
      const statusEl = document.getElementById('demo-status');
      const caseEl = document.getElementById('demo-case');
      const juryEl = document.getElementById('demo-jury');
      const verdictEl = document.getElementById('demo-verdict');
      const queueBtn = document.getElementById('demo-queue');
      const submitBtn = document.getElementById('demo-submit');
      const trialHint = document.getElementById('trial-hint');
      const judgeBtn = document.getElementById('demo-judge');
      const docketEl = document.getElementById('docket-preview');
      const archiveEl = document.getElementById('archive-preview');
      const groqKeyInput = document.getElementById('groq-key');
      const groqModelSelect = document.getElementById('groq-model');
      const groqButton = document.getElementById('groq-run');
      const groqStatusEl = document.getElementById('groq-status');
      const groqOutputEl = document.getElementById('groq-output');
      const metricActiveCasesEl = document.getElementById('metric-active-cases');
      const metricQueueDepthEl = document.getElementById('metric-queue-depth');
      const metricArchiveCountEl = document.getElementById('metric-archive-count');
      const metricJurorCountEl = document.getElementById('metric-juror-count');

      let latestCase = null;
      let latestDeliberation = null;
      let latestTrial = null;
      const dateFormatter = new Intl.DateTimeFormat(undefined, {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });

      function setStatus(message) {
        statusEl.textContent = message;
      }

      function setGroqStatus(message) {
        if (groqStatusEl) {
          groqStatusEl.textContent = message;
        }
      }

      const trialGateStates = {
        idle: {
          text: 'Pre-trial',
          hint: 'Queue a case to unlock the courtroom.'
        },
        ready: {
          text: 'Proceed to trial',
          hint: 'Launch the courtroom to seat jurors and capture votes.'
        },
        running: {
          text: 'Court in session…',
          hint: 'Deliberation is underway — stay tuned for the jury ledger.'
        },
        deliberated: {
          text: 'Awaiting judge review',
          hint: 'Invite the judge to finalize the ruling and update the archive.'
        },
        done: {
          text: 'Trial complete',
          hint: 'Archive updated. Load another case to reopen the court.'
        }
      };

      function setTrialGate(state = 'idle') {
        if (!submitBtn) return;
        const next = trialGateStates[state] ?? trialGateStates.idle;
        submitBtn.dataset.state = state;
        submitBtn.textContent = next.text;
        submitBtn.disabled = state !== 'ready';
        submitBtn.classList.remove('trial-tab--ready', 'trial-tab--running', 'trial-tab--deliberated', 'trial-tab--done');
        if (state === 'ready') {
          submitBtn.classList.add('trial-tab--ready');
        } else if (state === 'running') {
          submitBtn.classList.add('trial-tab--running');
        } else if (state === 'deliberated') {
          submitBtn.classList.add('trial-tab--deliberated');
        } else if (state === 'done') {
          submitBtn.classList.add('trial-tab--done');
        }
        if (trialHint) {
          trialHint.textContent = next.hint;
        }
      }

      function escapeHtml(value) {
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatNumber(value, { digits = 0, fallback = '—' } = {}) {
        if (value === undefined || value === null) return fallback;
        const num = Number(value);
        if (Number.isNaN(num)) return fallback;
        return num.toLocaleString(undefined, {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        });
      }

      function formatDate(value) {
        if (!value) return '—';
        try {
          return dateFormatter.format(new Date(value));
        } catch (error) {
          console.warn('Unable to format date', value, error);
          return value;
        }
      }

      async function updateHeroMetrics({ inboxCases } = {}) {
        try {
          const inboxPromise = inboxCases
            ? Promise.resolve({ cases: inboxCases })
            : (window.JuryRuntime.loadInbox
              ? window.JuryRuntime.loadInbox()
              : window.JuryRuntime.loadJSON('./data/cases.inbox.json'));
          const [inboxPayload, queuePayload, archivePayload, jurorPayload] = await Promise.all([
            inboxPromise,
            window.JuryRuntime.loadJSON('./data/cases.queue.json'),
            window.JuryRuntime.loadJSON('./data/cases.archive.json'),
            window.JuryRuntime.loadJSON('./data/jurors.json')
          ]);

          const cases = Array.isArray(inboxCases)
            ? inboxCases
            : Array.isArray(inboxPayload?.cases)
              ? inboxPayload.cases
              : [];
          if (metricActiveCasesEl) {
            metricActiveCasesEl.textContent = formatNumber(cases.length);
          }

          const queueIds = Array.isArray(queuePayload?.ids) ? queuePayload.ids : [];
          if (metricQueueDepthEl) {
            metricQueueDepthEl.textContent = formatNumber(queueIds.length);
          }

          const archiveCases = Array.isArray(archivePayload?.cases) ? archivePayload.cases : [];
          if (metricArchiveCountEl) {
            metricArchiveCountEl.textContent = formatNumber(archiveCases.length);
          }

          const jurorList = Array.isArray(jurorPayload?.jurors)
            ? jurorPayload.jurors
            : Array.isArray(jurorPayload)
              ? jurorPayload
              : [];
          if (metricJurorCountEl) {
            metricJurorCountEl.textContent = formatNumber(jurorList.length);
          }
        } catch (error) {
          console.error('Unable to update hero metrics', error);
        }
      }

      function summarizeVotes(votes = []) {
        return votes.reduce(
          (acc, vote) => {
            if (!vote) return acc;
            const normalized = String(vote).toUpperCase();
            if (normalized === 'A' || normalized === 'B') {
              acc[normalized] = (acc[normalized] ?? 0) + 1;
            } else if (normalized === 'ABSTAIN') {
              acc.abstain = (acc.abstain ?? 0) + 1;
            }
            return acc;
          },
          { A: 0, B: 0, abstain: 0 }
        );
      }

      function formatVoteSplit(tally) {
        const base = `${formatNumber(tally.A)}-${formatNumber(tally.B)}`;
        if (!tally.abstain) {
          return base;
        }
        return `${base} • ${formatNumber(tally.abstain)} abstain`;
      }

      function renderVoteChips(tally) {
        return ['A', 'B', 'abstain']
          .filter((key) => tally[key] !== undefined)
          .map((key) => `<span class="signal-pill">${key.toUpperCase()}: ${formatNumber(tally[key])}</span>`)
          .join('');
      }

      function renderCase(caseData) {
        if (!caseData) {
          caseEl.innerHTML = '<h3>Active case</h3><p>No case selected yet. Queue a spotlight dispute to inspect metrics before submitting to the jury.</p>';
          updateGroqButtonState();
          setTrialGate('idle');
          return;
        }

        const tags = (caseData.tags || [])
          .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
          .join('');
        const signals = caseData.signals || {};
        const metrics = [
          { value: formatNumber(caseData.score, { digits: 1 }), label: 'Signal score' },
          { value: formatNumber(signals.upvotes), label: 'Supporters' },
          { value: formatNumber(signals.downvotes), label: 'Skeptics' },
          { value: formatNumber(signals.reports), label: 'Reports flagged' }
        ]
          .map(
            (metric) => `
              <div class="case-metric">
                <span>${metric.value}</span>
                <span>${metric.label}</span>
              </div>
            `
          )
          .join('');

        caseEl.innerHTML = `
          <h3>Active case</h3>
          <div class="demo-meta">
            <span><strong>ID:</strong> ${escapeHtml(caseData.id)}</span>
            <span><strong>Filed:</strong> ${formatDate(caseData.createdAt)}</span>
            <span><strong>Submitted by:</strong> ${escapeHtml(caseData.submittedBy || 'anonymous')}</span>
          </div>
          <h4>${escapeHtml(caseData.title)}</h4>
          <p>${escapeHtml(caseData.context)}</p>
          <div>
            <strong>Side A</strong>
            <p>${escapeHtml(caseData.sideA)}</p>
          </div>
          <div>
            <strong>Side B</strong>
            <p>${escapeHtml(caseData.sideB)}</p>
          </div>
          <div class="case-metric-grid">${metrics}</div>
          <div class="demo-tags">${tags}</div>
        `;
        updateGroqButtonState();
      }

      function renderJuryResult(result) {
        if (!juryEl) return;
        if (!result) {
          juryEl.innerHTML = '<h3>Jury deliberation</h3><p>Submit a queued case to the jury to see how the panel weighs the evidence before the judge rules.</p>';
          return;
        }

        const tally = summarizeVotes(result.votes || []);
        const panelists = Array.isArray(result.panel) && result.panel.length
          ? result.panel
              .map((juror) => `<span class="signal-pill">${escapeHtml(juror.name || juror.id || 'Juror')}</span>`)
              .join('')
          : '<span class="signal-pill">Panel data unavailable</span>';
        const transcript = Array.isArray(result.transcript) ? result.transcript.slice(-4) : [];
        const transcriptHtml = transcript.length
          ? `<div class="demo-transcript">${transcript
              .map(
                (line) => `
            <div class="demo-line">
              <strong>${escapeHtml(String(line.by || '').toUpperCase())} • ${escapeHtml(line.phase || 'phase')}</strong>
              <span>${escapeHtml(line.text || '')}</span>
            </div>
          `
              )
              .join('')}</div>`
          : '<p class="ai-muted">Transcript not available.</p>';
        const factors = Array.isArray(result.factors) && result.factors.length
          ? escapeHtml(result.factors.join(', '))
          : 'Panel did not highlight decisive factors.';

        juryEl.innerHTML = `
          <h3>Jury deliberation</h3>
          <div class="verdict-callout">
            <strong>Panel lean:</strong> ${escapeHtml(result.winner ?? 'undetermined')}
            <span>${factors}</span>
            <span><strong>Vote split:</strong> ${formatVoteSplit(tally)}</span>
            <div class="docket-metrics">${renderVoteChips(tally)}</div>
          </div>
          <div class="jury-highlight">
            <div>
              <strong>Seated jurors</strong>
              <div class="jury-panelists">${panelists}</div>
            </div>
            <div>
              <strong>Transcript highlights</strong>
              ${transcriptHtml}
            </div>
          </div>
        `;
      }

      function renderVerdict(result) {
        if (!verdictEl) return;
        if (!result) {
          verdictEl.innerHTML = '<h3>Judge ruling</h3><p>The final verdict appears here after the judge reviews the jury outcome.</p>';
          return;
        }

        const { case: caseData, transcript, verdict } = result;
        const recentLines = transcript.slice(-4);
        const transcriptHtml = recentLines
          .map(
            (line) => `
            <div class="demo-line">
              <strong>${escapeHtml(String(line.by || '').toUpperCase())} • ${escapeHtml(line.phase || 'phase')}</strong>
              <span>${escapeHtml(line.text || '')}</span>
            </div>
          `
          )
          .join('');
        const tally = verdict.tally || summarizeVotes(result.votes || []);
        const voteChips = renderVoteChips(tally);

        verdictEl.innerHTML = `
          <h3>Judge ruling</h3>
          <div class="verdict-callout">
            <strong>Winner:</strong> ${escapeHtml(verdict.winner)}
            <span>${escapeHtml(verdict.text)}</span>
            <span><strong>Vote split:</strong> ${escapeHtml(verdict.split)}</span>
            <div class="docket-metrics">${voteChips}</div>
          </div>
          <div>
            <strong>Factors considered</strong>
            <p>${escapeHtml((verdict.factors || []).join(', '))}</p>
          </div>
          <div>
            <strong>Transcript highlights</strong>
            <div class="demo-transcript">${transcriptHtml}</div>
          </div>
          <p><em>Archive updated with ${escapeHtml(caseData.id)} at ${new Date().toLocaleTimeString()}.</em></p>
        `;
      }

      function renderGroqOutput(result) {
        if (!groqOutputEl) return;
        if (!result) {
          groqOutputEl.innerHTML = `
            <h3>Groq AI verdict</h3>
            <p>Connect to Groq and request a verdict to compare external reasoning against the scripted simulation.</p>
          `;
          return;
        }

        const parsed = result.parsed || {};
        const factors = Array.isArray(parsed.factors) && parsed.factors.length
          ? `<ul class="ai-list">${parsed.factors
              .map((factor) => `<li>${escapeHtml(factor)}</li>`)
              .join('')}</ul>`
          : '<p class="ai-muted">No factors highlighted.</p>';
        const actions = Array.isArray(parsed.recommended_actions) && parsed.recommended_actions.length
          ? `<ul class="ai-list">${parsed.recommended_actions
              .map((action) => `<li>${escapeHtml(action)}</li>`)
              .join('')}</ul>`
          : '<p class="ai-muted">No follow-up actions recommended.</p>';

        groqOutputEl.innerHTML = `
          <h3>Groq AI verdict</h3>
          <div class="demo-meta">
            <span><strong>Model:</strong> ${escapeHtml(result.model)}</span>
            <span><strong>Confidence:</strong> ${escapeHtml(parsed.confidence ?? 'unknown')}</span>
            <span><strong>Winner:</strong> ${escapeHtml(parsed.winner ?? 'undetermined')}</span>
          </div>
          <p>${escapeHtml(parsed.summary ?? result.content ?? 'Groq returned an empty response.')}</p>
          <div>
            <strong>Key factors</strong>
            ${factors}
          </div>
          <div>
            <strong>Recommended actions</strong>
            ${actions}
          </div>
        `;
      }

      function updateGroqButtonState() {
        if (!groqButton) return;
        const hasKey = Boolean(groqKeyInput?.value?.trim());
        groqButton.disabled = !hasKey || !latestCase;
        if (!latestCase) {
          setGroqStatus('Queue a case before requesting Groq reasoning.');
        } else if (!hasKey) {
          setGroqStatus('Enter an API key to enable the Groq request.');
        }
      }

      async function handleQueueClick() {
        setStatus('Loading latest case…');
        queueBtn.disabled = true;
        setTrialGate('idle');
        if (judgeBtn) {
          judgeBtn.disabled = true;
          judgeBtn.classList.add('is-hidden');
        }
        try {
          const picked = await window.JuryRuntime.pickHourlyCase();
          if (!picked) {
            setStatus('No cases available in the inbox. Add one to the data pack to continue.');
            renderCase(null);
            renderJuryResult(null);
            renderVerdict(null);
            return;
          }
          latestCase = picked;
          latestDeliberation = null;
          latestTrial = null;
          renderCase(picked);
          renderJuryResult(null);
          renderVerdict(null);
          renderGroqOutput(null);
          setStatus(`Queued case ${picked.id}. Review the metrics below, then submit to the jury.`);
          setGroqStatus('Case queued. Submit to the jury or request Groq deliberation with Groq.');
          setTrialGate('ready');
        } catch (error) {
          console.error(error);
          setStatus('Unable to queue a case. Check the console for details.');
          renderCase(null);
          renderJuryResult(null);
          renderGroqOutput(null);
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleSubmitClick() {
        if (!latestCase) {
          setStatus('Queue a case before submitting to the jury.');
          setTrialGate('idle');
          return;
        }
        setStatus('Submitting case to jury…');
        queueBtn.disabled = true;
        setTrialGate('running');
        if (judgeBtn) judgeBtn.disabled = true;
        try {
          const result = await window.JuryRuntime.deliberateQueuedCase();
          if (!result) {
            setStatus('No case available to deliberate. Queue a submission first.');
            renderJuryResult(null);
            setTrialGate('ready');
            return;
          }
          latestCase = result.case;
          latestDeliberation = result;
          latestTrial = null;
          renderCase(latestCase);
          renderJuryResult(result);
          renderVerdict(null);
          setStatus(`Jury completed deliberation for ${result.case.id}. Review their findings, then run the judge.`);
          setGroqStatus('Jury verdict ready — request Groq deliberation or run the judge for a final ruling.');
          setTrialGate('deliberated');
          if (judgeBtn) {
            judgeBtn.classList.remove('is-hidden');
            judgeBtn.disabled = false;
          }
        } catch (error) {
          console.error(error);
          setStatus('Jury deliberation failed. Inspect the console output for more information.');
          setGroqStatus('Groq reasoning is unavailable until the error is resolved.');
          if (latestCase) {
            setTrialGate('ready');
          } else {
            setTrialGate('idle');
          }
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleJudgeClick() {
        if (!latestDeliberation) {
          setStatus('Submit the active case to the jury before requesting a judge ruling.');
          if (judgeBtn) judgeBtn.classList.add('is-hidden');
          return;
        }
        setStatus('Running judge ruling…');
        queueBtn.disabled = true;
        setTrialGate('running');
        if (judgeBtn) judgeBtn.disabled = true;
        try {
          const result = await window.JuryRuntime.runJudgeRuling(latestDeliberation);
          latestCase = result.case;
          latestTrial = result;
          latestDeliberation = result;
          renderCase(latestCase);
          renderJuryResult(result);
          renderVerdict(result);
          setStatus(`Judge finalized the ruling for ${result.case.id}. Case archived for review.`);
          setGroqStatus('Trial complete — request Groq deliberation to compare reasoning.');
          if (judgeBtn) judgeBtn.classList.add('is-hidden');
          setTrialGate('done');
          renderArchivePreview({ bust: true });
        } catch (error) {
          console.error(error);
          setStatus('Judge ruling failed. Inspect the console output for more information.');
          setGroqStatus('Groq reasoning is unavailable until the error is resolved.');
          if (judgeBtn) judgeBtn.disabled = false;
          setTrialGate('deliberated');
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleGroqClick() {
        if (!groqButton) return;
        const apiKey = groqKeyInput?.value?.trim();
        if (!apiKey) {
          setGroqStatus('Enter your Groq API key to continue.');
          updateGroqButtonState();
          return;
        }
        if (!latestCase) {
          setGroqStatus('Queue a case before requesting Groq reasoning.');
          updateGroqButtonState();
          return;
        }

        setGroqStatus('Requesting Groq deliberation…');
        groqButton.disabled = true;
        try {
          const result = await window.JuryRuntime.requestGroqVerdict({
            apiKey,
            caseData: latestCase,
            transcript: latestTrial?.transcript || latestDeliberation?.transcript,
            model: groqModelSelect?.value || undefined
          });
          renderGroqOutput(result);
          setGroqStatus('Groq verdict received. Review the panel for details.');
        } catch (error) {
          console.error(error);
          setGroqStatus(error.message || 'Unable to fetch Groq verdict.');
        } finally {
          updateGroqButtonState();
        }
      }

      async function renderDocketPreview() {
        if (!docketEl) return;
        try {
          const [inboxPayload, settings] = await Promise.all([
            window.JuryRuntime.loadInbox
              ? window.JuryRuntime.loadInbox()
              : window.JuryRuntime.loadJSON('./data/cases.inbox.json'),
            window.JuryRuntime.loadSettings()
          ]);
          const cases = Array.isArray(inboxPayload?.cases) ? inboxPayload.cases.slice(0, 50) : [];
          await updateHeroMetrics({ inboxCases: inboxPayload?.cases || [] });
          if (!cases.length) {
            docketEl.innerHTML = '<p class="demo-status">No active submissions. Add a case to the data pack to continue.</p>';
            return;
          }

          const now = new Date();
          const computeHot = (entry) => {
            try {
              return window.JuryRuntime.computeHotScore(entry, settings.ranking, now);
            } catch (error) {
              return Number(entry?.score) || 0;
            }
          };

          const chronological = cases
            .slice()
            .sort((a, b) => new Date(a.createdAt || 0) - new Date(b.createdAt || 0));
          const trendingOrder = cases
            .slice()
            .sort((a, b) => computeHot(b) - computeHot(a));
          const trendingMap = new Map();
          trendingOrder.forEach((entry, index) => {
            trendingMap.set(entry.id, index + 1);
          });

          const list = chronological
            .map((caseData, index) => {
              const tags = (caseData.tags || [])
                .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
                .join('');
              const signals = caseData.signals || {};
              const hotScore = computeHot(caseData);
              const trendingRank = trendingMap.get(caseData.id);
              const metricLabels = [];
              if (trendingRank !== undefined) {
                metricLabels.push(`Hot #${formatNumber(trendingRank, { digits: 0 })}`);
              }
              metricLabels.push(`Score ${formatNumber(hotScore, { digits: 1 })}`);
              if (signals.upvotes !== undefined) {
                metricLabels.push(`Upvotes ${formatNumber(signals.upvotes)}`);
              }
              if (signals.downvotes !== undefined) {
                metricLabels.push(`Downvotes ${formatNumber(signals.downvotes)}`);
              }
              if (signals.reports !== undefined) {
                metricLabels.push(`Reports ${formatNumber(signals.reports)}`);
              }
              const metrics = metricLabels
                .map((label) => `<span class="metric-chip">${escapeHtml(label)}</span>`)
                .join('');
              const hotRankText = trendingRank !== undefined
                ? `#${formatNumber(trendingRank, { digits: 0 })}`
                : '—';

              return `
                <li class="docket-item">
                  <div class="docket-header">
                    <div class="docket-title-group">
                      <span class="signal-pill">Filed #${escapeHtml(index + 1)}</span>
                      <h3 class="docket-title">${escapeHtml(caseData.title)}</h3>
                    </div>
                    <div class="docket-metrics">${metrics}</div>
                  </div>
                  <p>${escapeHtml(caseData.context)}</p>
                  <div class="demo-meta">
                    <span><strong>Filed:</strong> ${formatDate(caseData.createdAt)}</span>
                    <span><strong>Submitted by:</strong> ${escapeHtml(caseData.submittedBy || 'anonymous')}</span>
                    <span><strong>Hot rank:</strong> ${escapeHtml(hotRankText)}</span>
                  </div>
                  <div class="demo-tags">${tags}</div>
                </li>
              `;
            })
            .join('');

          docketEl.innerHTML = `<ul class="docket-list">${list}</ul>`;
        } catch (error) {
          console.error(error);
          docketEl.innerHTML = '<p class="demo-status">Unable to load docket preview. Check the console for details.</p>';
          await updateHeroMetrics();
        }
      }

      async function renderArchivePreview({ bust = false } = {}) {
        if (!archiveEl) return;
        try {
          const archive = await window.JuryRuntime.loadJSON('./data/cases.archive.json', { bust });
          const cases = Array.isArray(archive?.cases) ? archive.cases : [];
          if (!cases.length) {
            archiveEl.innerHTML = '<p class="demo-status">No rulings recorded yet. Run a full trial to populate the archive.</p>';
          } else {
            const list = cases
              .slice()
              .sort((a, b) => new Date(b.decidedAt || 0) - new Date(a.decidedAt || 0))
              .map((entry) => {
                const caseData = entry.case || {};
                const tags = Array.isArray(caseData.tags) && caseData.tags.length
                  ? `<div class="demo-tags">${caseData.tags
                      .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
                      .join('')}</div>`
                  : '<p class="ai-muted">No tags recorded.</p>';
                const panelists = Array.isArray(entry.panel) && entry.panel.length
                  ? `<div class="jury-panelists">${entry.panel
                      .map((juror) => `<span class="signal-pill">${escapeHtml(juror.name || juror.id || 'Juror')}</span>`)
                      .join('')}</div>`
                  : '<span class="signal-pill">Panel data unavailable</span>';
                const votes = Array.isArray(entry.votes) ? entry.votes : [];
                const tally = votes.length ? summarizeVotes(votes) : { A: 0, B: 0, abstain: 0 };
                const voteChips = votes.length
                  ? `<div class="docket-metrics">${renderVoteChips(tally)}</div>`
                  : '<p class="ai-muted">Vote breakdown unavailable.</p>';
                const transcript = Array.isArray(entry.transcript) ? entry.transcript.slice(-3) : [];
                const transcriptHtml = transcript.length
                  ? `<div class="demo-transcript">${transcript
                      .map(
                        (line) => `
                <div class="demo-line">
                  <strong>${escapeHtml(String(line.by || '').toUpperCase())} • ${escapeHtml(line.phase || 'phase')}</strong>
                  <span>${escapeHtml(line.text || '')}</span>
                </div>
              `
                      )
                      .join('')}</div>`
                  : '<p class="ai-muted">Transcript not available.</p>';

                return `
                <li class="docket-item">
                  <div class="docket-header">
                    <h3 class="docket-title">${escapeHtml(caseData.title || entry.id)}</h3>
                    <div class="docket-metrics">
                      <span class="signal-pill">Winner: ${escapeHtml(entry.verdict?.winner ?? '—')}</span>
                      <span class="signal-pill">Split: ${escapeHtml(entry.verdict?.split ?? '—')}</span>
                    </div>
                  </div>
                  <p>${escapeHtml(caseData.context || entry.summary || 'No case context provided.')}</p>
                  <div class="demo-meta">
                    <span><strong>Ruled:</strong> ${formatDate(entry.decidedAt)}</span>
                    <span><strong>Case ID:</strong> ${escapeHtml(entry.id)}</span>
                  </div>
                  <div>
                    <strong>Arguments</strong>
                    <div class="demo-meta">
                      <span><em>Side A:</em> ${escapeHtml(caseData.sideA ?? 'Not recorded')}</span>
                      <span><em>Side B:</em> ${escapeHtml(caseData.sideB ?? 'Not recorded')}</span>
                    </div>
                  </div>
                  ${tags}
                  <div>
                    <strong>Panel</strong>
                    ${panelists}
                  </div>
                  <div>
                    <strong>Vote tally</strong>
                    ${voteChips}
                  </div>
                  <div>
                    <strong>Transcript highlights</strong>
                    ${transcriptHtml}
                  </div>
                  <div>
                    <strong>Summary</strong>
                    <p>${escapeHtml(entry.summary || 'No summary recorded.')}</p>
                  </div>
                </li>
              `;
              })
              .join('');

            archiveEl.innerHTML = `<ul class="docket-list">${list}</ul>`;
          }

          await updateHeroMetrics();
        } catch (error) {
          console.error(error);
          archiveEl.innerHTML = '<p class="demo-status">Unable to load the archive. Check the console for details.</p>';
          await updateHeroMetrics();
        }
      }

      queueBtn.addEventListener('click', handleQueueClick);
      if (submitBtn) {
        submitBtn.addEventListener('click', handleSubmitClick);
      }
      if (judgeBtn) {
        judgeBtn.addEventListener('click', handleJudgeClick);
      }
      if (groqButton) {
        groqButton.addEventListener('click', handleGroqClick);
      }
      if (groqKeyInput) {
        groqKeyInput.addEventListener('input', updateGroqButtonState);
      }

      setTrialGate('idle');
      renderCase(null);
      renderJuryResult(null);
      renderVerdict(null);
      renderGroqOutput(null);
      renderDocketPreview();
      renderArchivePreview();
      updateGroqButtonState();
    })();
  </script>

</body>
</html>
