<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jury Game 3.0 â€¢ Live Courtroom</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/inter@5.0.16/variable.css">
  <style>
    :root {
      color-scheme: only light;
      --bg: linear-gradient(135deg, #fef6ec 0%, #f0f7ff 45%, #f9f2ff 100%);
      --text: #0f1b3d;
      --muted: #445274;
      --muted-strong: #152046;
      --accent: #6366f1;
      --accent-strong: #4338ca;
      --accent-soft: rgba(99, 102, 241, 0.14);
      --accent-secondary: #f97316;
      --accent-secondary-soft: rgba(249, 115, 22, 0.16);
      --border: rgba(15, 27, 61, 0.08);
      --card-bg: rgba(255, 255, 255, 0.82);
      --surface: rgba(255, 255, 255, 0.68);
      --shadow: 0 28px 54px rgba(15, 27, 61, 0.16);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "InterVariable", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 64px 16px 120px;
    }

    main {
      width: min(960px, 100%);
      display: grid;
      gap: 32px;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 28px;
      padding: 36px;
      backdrop-filter: blur(16px);
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px solid var(--border);
      pointer-events: none;
    }

    h1, h2, h3 {
      margin: 0 0 16px;
      line-height: 1.1;
    }

    p {
      margin: 0 0 16px;
      line-height: 1.6;
      color: var(--muted);
      font-size: 1.02rem;
    }

    .hero {
      display: grid;
      gap: 36px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: stretch;
    }

    .hero-body {
      display: grid;
      gap: 20px;
    }

    .hero-body p {
      font-size: 1.08rem;
      color: var(--muted);
    }

    .hero-foot {
      display: grid;
      gap: 20px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.7);
      color: var(--accent-strong);
      font-weight: 600;
      border-radius: 999px;
      padding: 7px 16px;
      text-transform: uppercase;
      font-size: 0.72rem;
      letter-spacing: 0.12em;
    }

    .hero h1 {
      font-size: clamp(2.5rem, 4.4vw, 3.5rem);
      color: var(--muted-strong);
    }

    .hero-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .metric {
      padding: 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92) 0%, rgba(255, 255, 255, 0.72) 100%);
      display: grid;
      gap: 6px;
      position: relative;
      overflow: hidden;
    }

    .metric::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(95, 77, 255, 0.08) 0%, rgba(255, 255, 255, 0) 60%);
      pointer-events: none;
    }

    .metric span:first-child {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
    }

    .metric span:last-child {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .pill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    .pill {
      padding: 9px 16px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.14);
      color: var(--accent-strong);
      font-weight: 600;
      font-size: 0.82rem;
    }

    .feature-list {
      display: grid;
      gap: 16px;
      margin-top: 8px;
      padding: 0;
      list-style: none;
    }

    .feature {
      display: grid;
      gap: 8px;
      padding: 20px 22px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.54);
      background: rgba(255, 255, 255, 0.74);
    }

    .feature strong {
      font-size: 1.05rem;
      color: var(--text);
    }

    .timeline {
      display: grid;
      gap: 18px;
      list-style: none;
      padding: 0;
      margin: 20px 0 0;
    }

    .timeline li {
      display: grid;
      gap: 6px;
      padding-left: 22px;
      position: relative;
    }

    .timeline li::before {
      content: "";
      position: absolute;
      left: 0;
      top: 4px;
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(95, 77, 255, 0.14);
    }

    .demo-grid {
      display: grid;
      gap: 24px;
    }

    .demo-actions {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: start;
    }

    .trial-gate {
      display: grid;
      gap: 8px;
      padding: 18px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.86);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.48);
    }

    .trial-tab {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 20px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(99, 102, 241, 0.08);
      color: var(--accent-strong);
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    .trial-tab:disabled {
      cursor: not-allowed;
      opacity: 0.72;
      box-shadow: none;
    }

    .trial-tab--ready {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      color: #fff;
      box-shadow: 0 18px 36px rgba(99, 102, 241, 0.28);
    }

    .trial-tab--ready:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 22px 42px rgba(99, 102, 241, 0.32);
    }

    .trial-tab--running {
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    .trial-tab--deliberated {
      background: var(--accent-secondary-soft);
      color: var(--accent-secondary);
    }

    .trial-tab--done {
      background: rgba(15, 27, 61, 0.08);
      color: var(--muted-strong);
    }

    .trial-hint {
      font-size: 0.82rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .demo-status {
      margin-top: 12px;
      padding: 14px 18px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.54);
      background: rgba(255, 255, 255, 0.72);
      font-size: 0.9rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .demo-panels {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .demo-panel {
      padding: 22px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.52);
      background: rgba(255, 255, 255, 0.74);
      display: grid;
      gap: 14px;
    }

    .input-field {
      display: grid;
      gap: 6px;
    }

    .input-field label {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--muted);
    }

    .input-field input,
    .input-field select {
      border-radius: 999px;
      border: 1px solid rgba(95, 77, 255, 0.24);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 16px;
      font-size: 0.92rem;
      font-family: inherit;
      color: var(--muted-strong);
      outline: none;
    }

    .input-field input:focus,
    .input-field select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(95, 77, 255, 0.16);
    }

    .ai-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .ai-status {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .ai-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
      color: var(--muted);
      font-size: 0.88rem;
    }

    .ai-muted {
      color: rgba(31, 36, 48, 0.6);
      font-size: 0.86rem;
    }

    .demo-panel h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .jury-highlight {
      display: grid;
      gap: 10px;
    }

    .jury-panelists {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .demo-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.82rem;
      color: var(--muted);
    }

    .demo-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .demo-tag {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.16);
      color: var(--accent-strong);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .demo-transcript {
      display: grid;
      gap: 10px;
    }

    .demo-line {
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(95, 77, 255, 0.16);
      background: rgba(95, 77, 255, 0.07);
      font-size: 0.9rem;
      color: var(--muted);
    }

    .demo-line strong {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      margin-bottom: 4px;
    }

    .verdict-callout {
      padding: 16px 18px;
      border-radius: 18px;
      background: rgba(95, 77, 255, 0.14);
      border: 1px solid rgba(95, 77, 255, 0.32);
      color: var(--text);
      display: grid;
      gap: 6px;
    }

    .action-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-top: 24px;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 14px 26px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.98rem;
      letter-spacing: 0.01em;
      text-decoration: none;
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .is-hidden {
      display: none !important;
    }

    .button--primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      color: #fff;
      box-shadow: 0 20px 38px rgba(99, 102, 241, 0.26);
    }

    .button--ghost {
      background: rgba(255, 255, 255, 0.78);
      color: var(--accent);
      border: 1px solid rgba(99, 102, 241, 0.34);
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 24px 42px rgba(99, 102, 241, 0.28);
    }

    .section-intro {
      display: grid;
      gap: 10px;
      margin-bottom: 18px;
    }

    .section-intro span {
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--accent);
      font-weight: 600;
    }

    .docket-list {
      display: grid;
      gap: 16px;
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .docket-item {
      display: grid;
      gap: 12px;
      padding: 20px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.68);
    }

    .docket-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
    }

    .docket-title-group {
      display: grid;
      gap: 6px;
    }

    .docket-title {
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--muted-strong);
      margin: 0;
    }

    .docket-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .metric-chip {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(95, 77, 255, 0.12);
      color: var(--accent-strong);
      font-size: 0.78rem;
      font-weight: 600;
    }

    .case-metric-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .case-metric {
      display: grid;
      gap: 4px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.52);
      background: rgba(255, 255, 255, 0.7);
    }

    .case-metric span:first-child {
      font-weight: 700;
      font-size: 1.2rem;
      color: var(--accent);
    }

    .case-metric span:last-child {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .signal-pill {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(18, 21, 43, 0.06);
      color: var(--muted-strong);
      font-size: 0.78rem;
      font-weight: 600;
    }

    footer {
      margin-top: 36px;
      text-align: center;
      color: rgba(31, 36, 48, 0.48);
      font-size: 0.85rem;
    }

    @media (max-width: 720px) {
      body {
        padding-top: 40px;
      }

      .card {
        padding: 28px;
      }

      .demo-panels {
        grid-template-columns: 1fr;
      }

      .hero-grid {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="card hero">
      <div class="hero-body">
        <span class="badge">Jury Game 3.0 live build</span>
        <h1>One glass dashboard for trials, verdicts, and archives.</h1>
        <p>
          This is the canonical Jury Game home â€” the sandbox, verdict log, and telemetry readouts that power the live
          courtroom now sit on a single page. Load new controversies, watch the jury deliberate, and confirm every ruling
          lands in the archive without jumping between prototype links.
        </p>
        <div class="pill-list">
          <span class="pill">Live docket sync</span>
          <span class="pill">Transparent verdict archive</span>
          <span class="pill">Autonomous counsel</span>
          <span class="pill">Optional Groq co-judge</span>
        </div>
        <div class="action-strip">
          <a class="button button--primary" href="#live-trial">Launch the live trial flow</a>
          <a class="button button--ghost" href="#archive">Review resolved cases</a>
        </div>
      </div>
      <div class="hero-foot">
        <div class="hero-grid">
          <div class="metric">
            <span id="metric-active-cases">â€”</span>
            <span>Active controversies ready to schedule</span>
          </div>
          <div class="metric">
            <span id="metric-queue-depth">â€”</span>
            <span>Cases waiting in the hourly spotlight queue</span>
          </div>
          <div class="metric">
            <span id="metric-archive-count">â€”</span>
            <span>Resolved trials logged in the archive</span>
          </div>
          <div class="metric">
            <span id="metric-juror-count">â€”</span>
            <span>AI jurors on rotation</span>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Live systems</span>
        <h2>What powers the live courtroom</h2>
      </div>
      <p>
        The infrastructure below now backs the public-facing build. Every module pipes into a shared state store so jurors
        and moderators always reference the same facts, telemetry, and transcripts while the case is in flight.
      </p>
      <ul class="feature-list">
        <li class="feature">
          <strong>Persistent case archive</strong>
          <p>
            Cloud-backed storage keeps the docket intact between visits. Cases decay using a freshness score so new posts
            surface organically, while historically significant trials remain searchable.
          </p>
        </li>
        <li class="feature">
          <strong>Cross-visitor synchronization</strong>
          <p>
            The board updates in real-time when jurors vote or comment. We expose a channel log for moderators and a
            visual heartbeat indicator for visitors to confirm when the sim is live.
          </p>
        </li>
        <li class="feature">
          <strong>Autonomous counsel behaviors</strong>
          <p>
            Prosecutor, defender, and mediator agents now reference shared memory. They can resume suspended cases,
            escalate unusual activity, and request human arbitration with a single tap.
          </p>
        </li>
        <li class="feature">
          <strong>Emotion telemetry dashboard</strong>
          <p>
            Sentiment analysis runs on every new comment. Jurors see simplified mood meters while moderators can drill into
            raw scores to understand volatility within each case thread.
          </p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Daily cadence</span>
        <h2>How the trial cycles</h2>
      </div>
      <p>
        The live build processes headline controversies on a predictable loop so you can drop in at any moment. Each phase
        keeps the docket fresh while leaving space to audit transcripts and run manual reviews.
      </p>
      <ul class="timeline">
        <li>
          <strong>Morning â€” Inbox refresh</strong>
          <p>New filings join the inbox and top-ranking cases queue up for the next public session.</p>
        </li>
        <li>
          <strong>Afternoon â€” Jury session</strong>
          <p>Panels deliberate with scripted counsel while moderators monitor mood telemetry and vote splits.</p>
        </li>
        <li>
          <strong>Evening â€” Archive sweep</strong>
          <p>Judge rulings land in the archive, highlight reels generate, and the queue resets for the next cycle.</p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Up Next</span>
        <h2>What we still owe you</h2>
      </div>
      <p>
        Three additional modules are in active development. Expect preview builds through the shared folder before the
        next sync.
      </p>
      <ul class="feature-list">
        <li class="feature">
          <strong>Juror reputation loop</strong>
          <p>Designing streak-based rewards that influence future seating priority without punishing casual players.</p>
        </li>
        <li class="feature">
          <strong>Live verdict broadcast</strong>
          <p>Building a marquee for big decisions, including automated highlight reels for social sharing.</p>
        </li>
        <li class="feature">
          <strong>Scenario writer toolkit</strong>
          <p>Packaging our internal case generator so partners can author bespoke dilemmas with guardrails.</p>
        </li>
      </ul>
    </section>

    <section class="card">
      <div class="section-intro">
        <span>Docket</span>
        <h2>Spotlight controversies on the docket</h2>
      </div>
      <p>
        The docket caps at 50 active controversies pulled from todayâ€™s news cycle. This same feed powers the sandbox
        below, so anything you see listed here can be queued, deliberated, and archived in real time without swapping
        tabs.
      </p>
      <div id="docket-preview">
        <p class="demo-status">Loading docket metricsâ€¦</p>
      </div>
    </section>

    <section class="card" id="live-trial">
      <div class="section-intro">
        <span>Live trial</span>
        <h2>Run the full flow</h2>
      </div>
      <p>
        Queue up the latest community submission, submit it to the jury for deliberation, and then invite the judge to
        finalize the ruling using the deterministic helpers in <code>app.js</code>. Everything loads locally from the JSON
        data pack that also drives the live build, so youâ€™re exercising the exact workflow jurors experience.
      </p>
      <div class="demo-grid">
        <div class="demo-actions">
          <button class="button button--primary" id="demo-queue">Load next headline case</button>
          <div class="trial-gate">
            <button class="trial-tab" id="demo-submit" disabled>Pre-trial</button>
            <span class="trial-hint" id="trial-hint">Queue a case to unlock the courtroom.</span>
          </div>
          <button class="button button--ghost is-hidden" id="demo-judge" disabled>Finalize judge ruling</button>
        </div>
        <div class="demo-status" id="demo-status">Pre-trial â€” load a case to ready the courtroom.</div>
        <div class="demo-panel ai-panel">
          <h3>Groq deliberation boost</h3>
          <p>Bring your Groq API key to sample an additional AI verdict that weighs both sides of the dispute.</p>
          <div class="input-field">
            <label for="groq-key">Groq API key</label>
            <input type="password" id="groq-key" placeholder="gsk_â€¦" autocomplete="off" spellcheck="false">
          </div>
          <div class="input-field">
            <label for="groq-model">Model</label>
            <select id="groq-model">
              <option value="llama3-70b-8192">llama3-70b-8192</option>
              <option value="llama3-8b-8192">llama3-8b-8192</option>
            </select>
          </div>
          <div class="ai-inline">
            <button class="button button--ghost" id="groq-run" disabled>Request Groq verdict</button>
            <span class="ai-status" id="groq-status">Enter an API key and queue a case to unlock Groq reasoning.</span>
          </div>
        </div>
        <div class="demo-panels">
          <div class="demo-panel" id="demo-case">
            <h3>Active case</h3>
            <p>No case selected yet. Queue a spotlight dispute to inspect metrics before running the trial.</p>
          </div>
          <div class="demo-panel" id="demo-jury">
            <h3>Jury deliberation</h3>
            <p>Submit a queued case to the jury to see how the panel weighs the evidence before the judge rules.</p>
          </div>
          <div class="demo-panel" id="demo-verdict">
            <h3>Judge ruling</h3>
            <p>The final verdict appears here after the judge reviews the jury outcome.</p>
          </div>
          <div class="demo-panel" id="groq-output">
            <h3>Groq AI verdict</h3>
            <p>Connect to Groq and request a verdict to compare external reasoning against the scripted simulation.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="card" id="archive">
      <div class="section-intro">
        <span>Archive</span>
        <h2>Resolved cases</h2>
      </div>
      <p>
        Every ruling recorded in the live sandbox lands here immediately. Audit full briefs, transcripts, and vote splits
        without leaving the page.
      </p>
      <div id="archive-preview">
        <p class="demo-status">Archive populates after rulings are recorded.</p>
      </div>
    </section>
  </main>

  <footer>
    Jury Game 3.0 â€¢ Live courtroom build for moderators, jurors, and reviewers
  </footer>

  <script src="app.js"></script>
  <script>
    (function () {
      const statusEl = document.getElementById('demo-status');
      const caseEl = document.getElementById('demo-case');
      const juryEl = document.getElementById('demo-jury');
      const verdictEl = document.getElementById('demo-verdict');
      const queueBtn = document.getElementById('demo-queue');
      const submitBtn = document.getElementById('demo-submit');
      const trialHint = document.getElementById('trial-hint');
      const judgeBtn = document.getElementById('demo-judge');
      const docketEl = document.getElementById('docket-preview');
      const archiveEl = document.getElementById('archive-preview');
      const groqKeyInput = document.getElementById('groq-key');
      const groqModelSelect = document.getElementById('groq-model');
      const groqButton = document.getElementById('groq-run');
      const groqStatusEl = document.getElementById('groq-status');
      const groqOutputEl = document.getElementById('groq-output');
      const metricActiveCasesEl = document.getElementById('metric-active-cases');
      const metricQueueDepthEl = document.getElementById('metric-queue-depth');
      const metricArchiveCountEl = document.getElementById('metric-archive-count');
      const metricJurorCountEl = document.getElementById('metric-juror-count');

      let latestCase = null;
      let latestDeliberation = null;
      let latestTrial = null;
      const dateFormatter = new Intl.DateTimeFormat(undefined, {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });

      function setStatus(message) {
        statusEl.textContent = message;
      }

      function setGroqStatus(message) {
        if (groqStatusEl) {
          groqStatusEl.textContent = message;
        }
      }

      const trialGateStates = {
        idle: {
          text: 'Pre-trial',
          hint: 'Queue a case to unlock the courtroom.'
        },
        ready: {
          text: 'Proceed to trial',
          hint: 'Launch the courtroom to seat jurors and capture votes.'
        },
        running: {
          text: 'Court in sessionâ€¦',
          hint: 'Deliberation is underway â€” stay tuned for the jury ledger.'
        },
        deliberated: {
          text: 'Awaiting judge review',
          hint: 'Invite the judge to finalize the ruling and update the archive.'
        },
        done: {
          text: 'Trial complete',
          hint: 'Archive updated. Load another case to reopen the court.'
        }
      };

      function setTrialGate(state = 'idle') {
        if (!submitBtn) return;
        const next = trialGateStates[state] ?? trialGateStates.idle;
        submitBtn.dataset.state = state;
        submitBtn.textContent = next.text;
        submitBtn.disabled = state !== 'ready';
        submitBtn.classList.remove('trial-tab--ready', 'trial-tab--running', 'trial-tab--deliberated', 'trial-tab--done');
        if (state === 'ready') {
          submitBtn.classList.add('trial-tab--ready');
        } else if (state === 'running') {
          submitBtn.classList.add('trial-tab--running');
        } else if (state === 'deliberated') {
          submitBtn.classList.add('trial-tab--deliberated');
        } else if (state === 'done') {
          submitBtn.classList.add('trial-tab--done');
        }
        if (trialHint) {
          trialHint.textContent = next.hint;
        }
      }

      function escapeHtml(value) {
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatNumber(value, { digits = 0, fallback = 'â€”' } = {}) {
        if (value === undefined || value === null) return fallback;
        const num = Number(value);
        if (Number.isNaN(num)) return fallback;
        return num.toLocaleString(undefined, {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        });
      }

      function formatDate(value) {
        if (!value) return 'â€”';
        try {
          return dateFormatter.format(new Date(value));
        } catch (error) {
          console.warn('Unable to format date', value, error);
          return value;
        }
      }

      async function updateHeroMetrics({ inboxCases } = {}) {
        try {
          const inboxPromise = inboxCases
            ? Promise.resolve({ cases: inboxCases })
            : (window.JuryRuntime.loadInbox
              ? window.JuryRuntime.loadInbox()
              : window.JuryRuntime.loadJSON('./data/cases.inbox.json'));
          const [inboxPayload, queuePayload, archivePayload, jurorPayload] = await Promise.all([
            inboxPromise,
            window.JuryRuntime.loadJSON('./data/cases.queue.json'),
            window.JuryRuntime.loadJSON('./data/cases.archive.json'),
            window.JuryRuntime.loadJSON('./data/jurors.json')
          ]);

          const cases = Array.isArray(inboxCases)
            ? inboxCases
            : Array.isArray(inboxPayload?.cases)
              ? inboxPayload.cases
              : [];
          if (metricActiveCasesEl) {
            metricActiveCasesEl.textContent = formatNumber(cases.length);
          }

          const queueIds = Array.isArray(queuePayload?.ids) ? queuePayload.ids : [];
          if (metricQueueDepthEl) {
            metricQueueDepthEl.textContent = formatNumber(queueIds.length);
          }

          const archiveCases = Array.isArray(archivePayload?.cases) ? archivePayload.cases : [];
          if (metricArchiveCountEl) {
            metricArchiveCountEl.textContent = formatNumber(archiveCases.length);
          }

          const jurorList = Array.isArray(jurorPayload?.jurors)
            ? jurorPayload.jurors
            : Array.isArray(jurorPayload)
              ? jurorPayload
              : [];
          if (metricJurorCountEl) {
            metricJurorCountEl.textContent = formatNumber(jurorList.length);
          }
        } catch (error) {
          console.error('Unable to update hero metrics', error);
        }
      }

      function summarizeVotes(votes = []) {
        return votes.reduce(
          (acc, vote) => {
            if (!vote) return acc;
            const normalized = String(vote).toUpperCase();
            if (normalized === 'A' || normalized === 'B') {
              acc[normalized] = (acc[normalized] ?? 0) + 1;
            } else if (normalized === 'ABSTAIN') {
              acc.abstain = (acc.abstain ?? 0) + 1;
            }
            return acc;
          },
          { A: 0, B: 0, abstain: 0 }
        );
      }

      function formatVoteSplit(tally) {
        const base = `${formatNumber(tally.A)}-${formatNumber(tally.B)}`;
        if (!tally.abstain) {
          return base;
        }
        return `${base} â€¢ ${formatNumber(tally.abstain)} abstain`;
      }

      function renderVoteChips(tally) {
        return ['A', 'B', 'abstain']
          .filter((key) => tally[key] !== undefined)
          .map((key) => `<span class="signal-pill">${key.toUpperCase()}: ${formatNumber(tally[key])}</span>`)
          .join('');
      }

      function renderCase(caseData) {
        if (!caseData) {
          caseEl.innerHTML = '<h3>Active case</h3><p>No case selected yet. Queue a spotlight dispute to inspect metrics before submitting to the jury.</p>';
          updateGroqButtonState();
          setTrialGate('idle');
          return;
        }

        const tags = (caseData.tags || [])
          .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
          .join('');
        const signals = caseData.signals || {};
        const metrics = [
          { value: formatNumber(caseData.score, { digits: 1 }), label: 'Signal score' },
          { value: formatNumber(signals.upvotes), label: 'Supporters' },
          { value: formatNumber(signals.downvotes), label: 'Skeptics' },
          { value: formatNumber(signals.reports), label: 'Reports flagged' }
        ]
          .map(
            (metric) => `
              <div class="case-metric">
                <span>${metric.value}</span>
                <span>${metric.label}</span>
              </div>
            `
          )
          .join('');

        caseEl.innerHTML = `
          <h3>Active case</h3>
          <div class="demo-meta">
            <span><strong>ID:</strong> ${escapeHtml(caseData.id)}</span>
            <span><strong>Filed:</strong> ${formatDate(caseData.createdAt)}</span>
            <span><strong>Submitted by:</strong> ${escapeHtml(caseData.submittedBy || 'anonymous')}</span>
          </div>
          <h4>${escapeHtml(caseData.title)}</h4>
          <p>${escapeHtml(caseData.context)}</p>
          <div>
            <strong>Side A</strong>
            <p>${escapeHtml(caseData.sideA)}</p>
          </div>
          <div>
            <strong>Side B</strong>
            <p>${escapeHtml(caseData.sideB)}</p>
          </div>
          <div class="case-metric-grid">${metrics}</div>
          <div class="demo-tags">${tags}</div>
        `;
        updateGroqButtonState();
      }

      function renderJuryResult(result) {
        if (!juryEl) return;
        if (!result) {
          juryEl.innerHTML = '<h3>Jury deliberation</h3><p>Submit a queued case to the jury to see how the panel weighs the evidence before the judge rules.</p>';
          return;
        }

        const tally = summarizeVotes(result.votes || []);
        const panelists = Array.isArray(result.panel) && result.panel.length
          ? result.panel
              .map((juror) => `<span class="signal-pill">${escapeHtml(juror.name || juror.id || 'Juror')}</span>`)
              .join('')
          : '<span class="signal-pill">Panel data unavailable</span>';
        const transcript = Array.isArray(result.transcript) ? result.transcript.slice(-4) : [];
        const transcriptHtml = transcript.length
          ? `<div class="demo-transcript">${transcript
              .map(
                (line) => `
            <div class="demo-line">
              <strong>${escapeHtml(String(line.by || '').toUpperCase())} â€¢ ${escapeHtml(line.phase || 'phase')}</strong>
              <span>${escapeHtml(line.text || '')}</span>
            </div>
          `
              )
              .join('')}</div>`
          : '<p class="ai-muted">Transcript not available.</p>';
        const factors = Array.isArray(result.factors) && result.factors.length
          ? escapeHtml(result.factors.join(', '))
          : 'Panel did not highlight decisive factors.';

        juryEl.innerHTML = `
          <h3>Jury deliberation</h3>
          <div class="verdict-callout">
            <strong>Panel lean:</strong> ${escapeHtml(result.winner ?? 'undetermined')}
            <span>${factors}</span>
            <span><strong>Vote split:</strong> ${formatVoteSplit(tally)}</span>
            <div class="docket-metrics">${renderVoteChips(tally)}</div>
          </div>
          <div class="jury-highlight">
            <div>
              <strong>Seated jurors</strong>
              <div class="jury-panelists">${panelists}</div>
            </div>
            <div>
              <strong>Transcript highlights</strong>
              ${transcriptHtml}
            </div>
          </div>
        `;
      }

      function renderVerdict(result) {
        if (!verdictEl) return;
        if (!result) {
          verdictEl.innerHTML = '<h3>Judge ruling</h3><p>The final verdict appears here after the judge reviews the jury outcome.</p>';
          return;
        }

        const { case: caseData, transcript, verdict } = result;
        const recentLines = transcript.slice(-4);
        const transcriptHtml = recentLines
          .map(
            (line) => `
            <div class="demo-line">
              <strong>${escapeHtml(String(line.by || '').toUpperCase())} â€¢ ${escapeHtml(line.phase || 'phase')}</strong>
              <span>${escapeHtml(line.text || '')}</span>
            </div>
          `
          )
          .join('');
        const tally = verdict.tally || summarizeVotes(result.votes || []);
        const voteChips = renderVoteChips(tally);

        verdictEl.innerHTML = `
          <h3>Judge ruling</h3>
          <div class="verdict-callout">
            <strong>Winner:</strong> ${escapeHtml(verdict.winner)}
            <span>${escapeHtml(verdict.text)}</span>
            <span><strong>Vote split:</strong> ${escapeHtml(verdict.split)}</span>
            <div class="docket-metrics">${voteChips}</div>
          </div>
          <div>
            <strong>Factors considered</strong>
            <p>${escapeHtml((verdict.factors || []).join(', '))}</p>
          </div>
          <div>
            <strong>Transcript highlights</strong>
            <div class="demo-transcript">${transcriptHtml}</div>
          </div>
          <p><em>Archive updated with ${escapeHtml(caseData.id)} at ${new Date().toLocaleTimeString()}.</em></p>
        `;
      }

      function renderGroqOutput(result) {
        if (!groqOutputEl) return;
        if (!result) {
          groqOutputEl.innerHTML = `
            <h3>Groq AI verdict</h3>
            <p>Connect to Groq and request a verdict to compare external reasoning against the scripted simulation.</p>
          `;
          return;
        }

        const parsed = result.parsed || {};
        const factors = Array.isArray(parsed.factors) && parsed.factors.length
          ? `<ul class="ai-list">${parsed.factors
              .map((factor) => `<li>${escapeHtml(factor)}</li>`)
              .join('')}</ul>`
          : '<p class="ai-muted">No factors highlighted.</p>';
        const actions = Array.isArray(parsed.recommended_actions) && parsed.recommended_actions.length
          ? `<ul class="ai-list">${parsed.recommended_actions
              .map((action) => `<li>${escapeHtml(action)}</li>`)
              .join('')}</ul>`
          : '<p class="ai-muted">No follow-up actions recommended.</p>';

        groqOutputEl.innerHTML = `
          <h3>Groq AI verdict</h3>
          <div class="demo-meta">
            <span><strong>Model:</strong> ${escapeHtml(result.model)}</span>
            <span><strong>Confidence:</strong> ${escapeHtml(parsed.confidence ?? 'unknown')}</span>
            <span><strong>Winner:</strong> ${escapeHtml(parsed.winner ?? 'undetermined')}</span>
          </div>
          <p>${escapeHtml(parsed.summary ?? result.content ?? 'Groq returned an empty response.')}</p>
          <div>
            <strong>Key factors</strong>
            ${factors}
          </div>
          <div>
            <strong>Recommended actions</strong>
            ${actions}
          </div>
        `;
      }

      function updateGroqButtonState() {
        if (!groqButton) return;
        const hasKey = Boolean(groqKeyInput?.value?.trim());
        groqButton.disabled = !hasKey || !latestCase;
        if (!latestCase) {
          setGroqStatus('Queue a case before requesting Groq reasoning.');
        } else if (!hasKey) {
          setGroqStatus('Enter an API key to enable the Groq request.');
        }
      }

      async function handleQueueClick() {
        setStatus('Loading latest caseâ€¦');
        queueBtn.disabled = true;
        setTrialGate('idle');
        if (judgeBtn) {
          judgeBtn.disabled = true;
          judgeBtn.classList.add('is-hidden');
        }
        try {
          const picked = await window.JuryRuntime.pickHourlyCase();
          if (!picked) {
            setStatus('No cases available in the inbox. Add one to the data pack to continue.');
            renderCase(null);
            renderJuryResult(null);
            renderVerdict(null);
            return;
          }
          latestCase = picked;
          latestDeliberation = null;
          latestTrial = null;
          renderCase(picked);
          renderJuryResult(null);
          renderVerdict(null);
          renderGroqOutput(null);
          setStatus(`Queued case ${picked.id}. Review the metrics below, then submit to the jury.`);
          setGroqStatus('Case queued. Submit to the jury or request Groq deliberation with Groq.');
          setTrialGate('ready');
        } catch (error) {
          console.error(error);
          setStatus('Unable to queue a case. Check the console for details.');
          renderCase(null);
          renderJuryResult(null);
          renderGroqOutput(null);
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleSubmitClick() {
        if (!latestCase) {
          setStatus('Queue a case before submitting to the jury.');
          setTrialGate('idle');
          return;
        }
        setStatus('Submitting case to juryâ€¦');
        queueBtn.disabled = true;
        setTrialGate('running');
        if (judgeBtn) judgeBtn.disabled = true;
        try {
          const result = await window.JuryRuntime.deliberateQueuedCase();
          if (!result) {
            setStatus('No case available to deliberate. Queue a submission first.');
            renderJuryResult(null);
            setTrialGate('ready');
            return;
          }
          latestCase = result.case;
          latestDeliberation = result;
          latestTrial = null;
          renderCase(latestCase);
          renderJuryResult(result);
          renderVerdict(null);
          setStatus(`Jury completed deliberation for ${result.case.id}. Review their findings, then run the judge.`);
          setGroqStatus('Jury verdict ready â€” request Groq deliberation or run the judge for a final ruling.');
          setTrialGate('deliberated');
          if (judgeBtn) {
            judgeBtn.classList.remove('is-hidden');
            judgeBtn.disabled = false;
          }
        } catch (error) {
          console.error(error);
          setStatus('Jury deliberation failed. Inspect the console output for more information.');
          setGroqStatus('Groq reasoning is unavailable until the error is resolved.');
          if (latestCase) {
            setTrialGate('ready');
          } else {
            setTrialGate('idle');
          }
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleJudgeClick() {
        if (!latestDeliberation) {
          setStatus('Submit the active case to the jury before requesting a judge ruling.');
          if (judgeBtn) judgeBtn.classList.add('is-hidden');
          return;
        }
        setStatus('Running judge rulingâ€¦');
        queueBtn.disabled = true;
        setTrialGate('running');
        if (judgeBtn) judgeBtn.disabled = true;
        try {
          const result = await window.JuryRuntime.runJudgeRuling(latestDeliberation);
          latestCase = result.case;
          latestTrial = result;
          latestDeliberation = result;
          renderCase(latestCase);
          renderJuryResult(result);
          renderVerdict(result);
          setStatus(`Judge finalized the ruling for ${result.case.id}. Case archived for review.`);
          setGroqStatus('Trial complete â€” request Groq deliberation to compare reasoning.');
          if (judgeBtn) judgeBtn.classList.add('is-hidden');
          setTrialGate('done');
          renderArchivePreview({ bust: true });
        } catch (error) {
          console.error(error);
          setStatus('Judge ruling failed. Inspect the console output for more information.');
          setGroqStatus('Groq reasoning is unavailable until the error is resolved.');
          if (judgeBtn) judgeBtn.disabled = false;
          setTrialGate('deliberated');
        } finally {
          queueBtn.disabled = false;
          updateGroqButtonState();
          await updateHeroMetrics();
        }
      }

      async function handleGroqClick() {
        if (!groqButton) return;
        const apiKey = groqKeyInput?.value?.trim();
        if (!apiKey) {
          setGroqStatus('Enter your Groq API key to continue.');
          updateGroqButtonState();
          return;
        }
        if (!latestCase) {
          setGroqStatus('Queue a case before requesting Groq reasoning.');
          updateGroqButtonState();
          return;
        }

        setGroqStatus('Requesting Groq deliberationâ€¦');
        groqButton.disabled = true;
        try {
          const result = await window.JuryRuntime.requestGroqVerdict({
            apiKey,
            caseData: latestCase,
            transcript: latestTrial?.transcript || latestDeliberation?.transcript,
            model: groqModelSelect?.value || undefined
          });
          renderGroqOutput(result);
          setGroqStatus('Groq verdict received. Review the panel for details.');
        } catch (error) {
          console.error(error);
          setGroqStatus(error.message || 'Unable to fetch Groq verdict.');
        } finally {
          updateGroqButtonState();
        }
      }

      async function renderDocketPreview() {
        if (!docketEl) return;
        try {
          const [inboxPayload, settings] = await Promise.all([
            window.JuryRuntime.loadInbox
              ? window.JuryRuntime.loadInbox()
              : window.JuryRuntime.loadJSON('./data/cases.inbox.json'),
            window.JuryRuntime.loadSettings()
          ]);
          const cases = Array.isArray(inboxPayload?.cases) ? inboxPayload.cases.slice(0, 50) : [];
          await updateHeroMetrics({ inboxCases: inboxPayload?.cases || [] });
          if (!cases.length) {
            docketEl.innerHTML = '<p class="demo-status">No active submissions. Add a case to the data pack to continue.</p>';
            return;
          }

          const now = new Date();
          const computeHot = (entry) => {
            try {
              return window.JuryRuntime.computeHotScore(entry, settings.ranking, now);
            } catch (error) {
              return Number(entry?.score) || 0;
            }
          };

          const chronological = cases
            .slice()
            .sort((a, b) => new Date(a.createdAt || 0) - new Date(b.createdAt || 0));
          const trendingOrder = cases
            .slice()
            .sort((a, b) => computeHot(b) - computeHot(a));
          const trendingMap = new Map();
          trendingOrder.forEach((entry, index) => {
            trendingMap.set(entry.id, index + 1);
          });

          const list = chronological
            .map((caseData, index) => {
              const tags = (caseData.tags || [])
                .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
                .join('');
              const signals = caseData.signals || {};
              const hotScore = computeHot(caseData);
              const trendingRank = trendingMap.get(caseData.id);
              const metricLabels = [];
              if (trendingRank !== undefined) {
                metricLabels.push(`Hot #${formatNumber(trendingRank, { digits: 0 })}`);
              }
              metricLabels.push(`Score ${formatNumber(hotScore, { digits: 1 })}`);
              if (signals.upvotes !== undefined) {
                metricLabels.push(`Upvotes ${formatNumber(signals.upvotes)}`);
              }
              if (signals.downvotes !== undefined) {
                metricLabels.push(`Downvotes ${formatNumber(signals.downvotes)}`);
              }
              if (signals.reports !== undefined) {
                metricLabels.push(`Reports ${formatNumber(signals.reports)}`);
              }
              const metrics = metricLabels
                .map((label) => `<span class="metric-chip">${escapeHtml(label)}</span>`)
                .join('');
              const hotRankText = trendingRank !== undefined
                ? `#${formatNumber(trendingRank, { digits: 0 })}`
                : 'â€”';

              return `
                <li class="docket-item">
                  <div class="docket-header">
                    <div class="docket-title-group">
                      <span class="signal-pill">Filed #${escapeHtml(index + 1)}</span>
                      <h3 class="docket-title">${escapeHtml(caseData.title)}</h3>
                    </div>
                    <div class="docket-metrics">${metrics}</div>
                  </div>
                  <p>${escapeHtml(caseData.context)}</p>
                  <div class="demo-meta">
                    <span><strong>Filed:</strong> ${formatDate(caseData.createdAt)}</span>
                    <span><strong>Submitted by:</strong> ${escapeHtml(caseData.submittedBy || 'anonymous')}</span>
                    <span><strong>Hot rank:</strong> ${escapeHtml(hotRankText)}</span>
                  </div>
                  <div class="demo-tags">${tags}</div>
                </li>
              `;
            })
            .join('');

          docketEl.innerHTML = `<ul class="docket-list">${list}</ul>`;
        } catch (error) {
          console.error(error);
          docketEl.innerHTML = '<p class="demo-status">Unable to load docket preview. Check the console for details.</p>';
          await updateHeroMetrics();
        }
      }

      async function renderArchivePreview({ bust = false } = {}) {
        if (!archiveEl) return;
        try {
          const archive = await window.JuryRuntime.loadJSON('./data/cases.archive.json', { bust });
          const cases = Array.isArray(archive?.cases) ? archive.cases : [];
          if (!cases.length) {
            archiveEl.innerHTML = '<p class="demo-status">No rulings recorded yet. Run a full trial to populate the archive.</p>';
          } else {
            const list = cases
              .slice()
              .sort((a, b) => new Date(b.decidedAt || 0) - new Date(a.decidedAt || 0))
              .map((entry) => {
                const caseData = entry.case || {};
                const tags = Array.isArray(caseData.tags) && caseData.tags.length
                  ? `<div class="demo-tags">${caseData.tags
                      .map((tag) => `<span class="demo-tag">${escapeHtml(tag)}</span>`)
                      .join('')}</div>`
                  : '<p class="ai-muted">No tags recorded.</p>';
                const panelists = Array.isArray(entry.panel) && entry.panel.length
                  ? `<div class="jury-panelists">${entry.panel
                      .map((juror) => `<span class="signal-pill">${escapeHtml(juror.name || juror.id || 'Juror')}</span>`)
                      .join('')}</div>`
                  : '<span class="signal-pill">Panel data unavailable</span>';
                const votes = Array.isArray(entry.votes) ? entry.votes : [];
                const tally = votes.length ? summarizeVotes(votes) : { A: 0, B: 0, abstain: 0 };
                const voteChips = votes.length
                  ? `<div class="docket-metrics">${renderVoteChips(tally)}</div>`
                  : '<p class="ai-muted">Vote breakdown unavailable.</p>';
                const transcript = Array.isArray(entry.transcript) ? entry.transcript.slice(-3) : [];
                const transcriptHtml = transcript.length
                  ? `<div class="demo-transcript">${transcript
                      .map(
                        (line) => `
                <div class="demo-line">
                  <strong>${escapeHtml(String(line.by || '').toUpperCase())} â€¢ ${escapeHtml(line.phase || 'phase')}</strong>
                  <span>${escapeHtml(line.text || '')}</span>
                </div>
              `
                      )
                      .join('')}</div>`
                  : '<p class="ai-muted">Transcript not available.</p>';

                return `
                <li class="docket-item">
                  <div class="docket-header">
                    <h3 class="docket-title">${escapeHtml(caseData.title || entry.id)}</h3>
                    <div class="docket-metrics">
                      <span class="signal-pill">Winner: ${escapeHtml(entry.verdict?.winner ?? 'â€”')}</span>
                      <span class="signal-pill">Split: ${escapeHtml(entry.verdict?.split ?? 'â€”')}</span>
                    </div>
                  </div>
                  <p>${escapeHtml(caseData.context || entry.summary || 'No case context provided.')}</p>
                  <div class="demo-meta">
                    <span><strong>Ruled:</strong> ${formatDate(entry.decidedAt)}</span>
                    <span><strong>Case ID:</strong> ${escapeHtml(entry.id)}</span>
                  </div>
                  <div>
                    <strong>Arguments</strong>
                    <div class="demo-meta">
                      <span><em>Side A:</em> ${escapeHtml(caseData.sideA ?? 'Not recorded')}</span>
                      <span><em>Side B:</em> ${escapeHtml(caseData.sideB ?? 'Not recorded')}</span>
                    </div>
                  </div>
                  ${tags}
                  <div>
                    <strong>Panel</strong>
                    ${panelists}
                  </div>
                  <div>
                    <strong>Vote tally</strong>
                    ${voteChips}
                  </div>
                  <div>
                    <strong>Transcript highlights</strong>
                    ${transcriptHtml}
                  </div>
                  <div>
                    <strong>Summary</strong>
                    <p>${escapeHtml(entry.summary || 'No summary recorded.')}</p>
                  </div>
                </li>
              `;
              })
              .join('');

            archiveEl.innerHTML = `<ul class="docket-list">${list}</ul>`;
          }

          await updateHeroMetrics();
        } catch (error) {
          console.error(error);
          archiveEl.innerHTML = '<p class="demo-status">Unable to load the archive. Check the console for details.</p>';
          await updateHeroMetrics();
        }
      }

      queueBtn.addEventListener('click', handleQueueClick);
      if (submitBtn) {
        submitBtn.addEventListener('click', handleSubmitClick);
      }
      if (judgeBtn) {
        judgeBtn.addEventListener('click', handleJudgeClick);
      }
      if (groqButton) {
        groqButton.addEventListener('click', handleGroqClick);
      }
      if (groqKeyInput) {
        groqKeyInput.addEventListener('input', updateGroqButtonState);
      }

      setTrialGate('idle');
      renderCase(null);
      renderJuryResult(null);
      renderVerdict(null);
      renderGroqOutput(null);
      renderDocketPreview();
      renderArchivePreview();
      updateGroqButtonState();
    })();
  </script>

</body>
</html>
